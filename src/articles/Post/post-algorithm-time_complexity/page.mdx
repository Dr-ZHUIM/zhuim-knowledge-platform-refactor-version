---
title: 时间复杂度分析
category: Algorithm
sidecategory: 
abstract: 本文将讲解时间复杂度的定义以及计算方式
cover: 
layer: Post
createdat: 2024-02-20 21:45
---

### 1. 什么是时间复杂度

时间复杂度是一个函数，它能够定性描述算法的运行时间。

时间复杂度能够辅助开发者开发者估算程序的运行时间，以此选择最优的算法。

时间复杂度的计算方式是：**在默认 CPU 的每个单元运行的消耗时间都相同的情况下，计算算法的操作单元数量**。

假设算法问题规模为 <Im>n</Im>， 那么操作单元数量使用函数 <Im>f(n)</Im> 来表示，随着数据规模的扩大， 算法执行的时间增长率与 <Im>f(n)</Im> 的增长率相同，这就是算法的渐进时间复杂度，简称时间复杂度

即为： <Im>O(f(n))</Im>

### 2. 什么是 上界 <Im> O </Im>

算法导论提出： <Im>O(n)</Im> 中的 O 指的是上界，我们用 O 作为算法最极端情况下运行时间的最大值，在该例子中指的是：数据输入为 n 个，最极端情况就要运行 n 次，得到的时间复杂度就是 $O(n)$

### 3. O(logn)中的 log 是以什么为底？

如果一个算法的时间复杂度为 <Im>O(log^n)</Im>， 并不代表这是一个底数为 2 的对数，我们在这里忽略底数的描述

原因如下:

假设两个算法的时间复杂度，分别是 <Im>O(log_(2)n)</Im> 和 <Im>O(log_(10)n)</Im>，容易得出：`以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数`

<Bm>O(log_(2)n) = log_(2)10 * O(log_(10)n)</Bm>

那么同理，任意两个，以常数为底数的 n 的对数都可以拆解成相同的概念，而 log_ij 是一个常数,在下文提到的化简方式中，会提到我们计算时间复杂度会忽略常数项系数。

<Bm>logi^n = O(log_(i)j * log_(j)n)</Bm>

至此我们得到以下左侧的函数，然后我们进一步忽略常数 i，得到最终的 <Im>O(log^n)</Im>

<Bm>O(log_(i)n) => O(log^n)</Bm>

### 4. 数据规模差异

应当注意的是：决定使用算法的时候，**不是时间复杂度越低越好**

因为： 简化后的时间复杂度会忽略掉常数项,也就是说，常数项大而数据规模很小的情况下，有可能 O(n^2)
的算法比 O(n) 的效率要高

比方说假设数据量小于 20，那么算法 5n^2 一定比 ^100n^ 要更有效率

<Aside title="O 的定义补充">
  这里就又涉及到O的定义，因为O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量。
</Aside>

### 5. 化简复杂表达式

有时候我们去计算时间复杂度的时候发现不是一个简单的 O(n) 或者 O(n^2)， 而是一个复杂的表达式，例如：


<Bm>O(2n^2 + 10n + 1000)</Bm>


我们往往使用简化法来计算时间复杂度。

去掉运行时间中的加法常数项 （因为常数项并不会因为 n 的增大而增加计算机的操作次数）。

<Bm>O(2n^2 + 10n)</Bm>

去掉常数项系数

<Bm>O(n^2 + n)</Bm>

只保留最高项，去掉数量级小一级的 n （因为 <Im>n^2</Im> 的数据规模远大于 n），最终简化为：

<Bm>O(n^2)</Bm>

<Aside title="另一种理解保留最高项的方式">
  将 <Im>O(n^2 + n)</Im> 合并同类项, 得到<Im>O(n(n + 1))</Im>，去除常数项，最终得到 <Im>O(n^2)</Im>
</Aside>

